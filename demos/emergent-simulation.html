<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emergent Simulation - promptsandmore.com</title>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
    <header>
        <h1><a href="../index.html" style="color: inherit; text-decoration: none;">promptsandmore.com</a></h1>
        <p class="tagline">Click. Tweak. Observe. Understand.</p>
    </header>

    <main class="demo-container">
        <div class="demo-header">
            <div class="breadcrumb">
                <a href="../index.html">Home</a> / Emergent Simulation
            </div>
            <h1>Emergent Simulation</h1>
            <p>Cellular automata, Reaction-diffusion, and cave generation</p>
        </div>

        <div class="demo-content">
            <div class="visualization-panel" id="visualization"></div>
            <div id="controls-container"></div>
        </div>

        <section class="info-section">
            <h2>System Overview</h2>
            <p>
                Cellular automata are discrete computational models where cells evolve based on rules applied to their
                neighbors. Simple rules create complex, emergent patterns. Conway's Game of Life is the most famous example,
                but many variations exist for different purposes.
            </p>
            <p>
                By tweaking birth and survival rules, we can create patterns ranging from stable structures to chaotic
                growth, oscillators, and gliders. These patterns emerge from local interactions, not global planning.
            </p>
        </section>

        <section class="info-section">
            <h2>Why Games Use This</h2>
            <ul>
                <li><strong>Cave Generation:</strong> Create organic cave systems with cellular automata</li>
                <li><strong>Ecosystem Simulation:</strong> Model population dynamics and interactions</li>
                <li><strong>Procedural Patterns:</strong> Generate textures, mazes, and structures</li>
                <li><strong>Emergent Behavior:</strong> Complex outcomes from simple rules</li>
                <li><strong>Deterministic:</strong> Same seed and rules = same result</li>
            </ul>
        </section>

        <section class="info-section">
            <h2>Key Parameters</h2>
            <ul>
                <li><strong>Birth Rules:</strong> Neighbor count range for dead cells to become alive</li>
                <li><strong>Survival Rules:</strong> Neighbor count range for alive cells to stay alive</li>
                <li><strong>Initial Density:</strong> Percentage of cells alive at start</li>
                <li><strong>Wrap Edges:</strong> Whether edges connect (torus topology)</li>
                <li><strong>Update Speed:</strong> Generations per second</li>
            </ul>
        </section>

        <section class="info-section">
            <h2>Failure Modes</h2>
            <ul>
                <li><strong>Too sparse:</strong> Low density causes everything to die</li>
                <li><strong>Too dense:</strong> High density causes overcrowding and death</li>
                <li><strong>Poor rules:</strong> Rules that don't balance lead to extinction or explosion</li>
                <li><strong>Edge artifacts:</strong> Non-wrapping edges create boundary effects</li>
                <li><strong>Performance:</strong> Large grids with fast updates are expensive</li>
            </ul>
        </section>

        <section class="info-section">
            <h2>Scaling Behavior</h2>
            <p>
                Each generation requires O(n) work for n cells. For real-time, limit grid size to 200×200 or use
                spatial optimization (only update active regions). Multi-threading can parallelize neighbor counting.
            </p>
            <p>
                Memory is O(n) for grid storage. Use bit packing for binary states to reduce memory by 8×.
            </p>
        </section>

        <section class="info-section">
            <h2>Related Algorithms</h2>
            <ul>
                <li><strong>Conway's Game of Life:</strong> B3/S23 rule (most famous)</li>
                <li><strong>Reaction-Diffusion:</strong> Continuous chemical patterns (Gray-Scott model)</li>
                <li><strong>Maze Generation:</strong> Cellular automata for cave-like mazes</li>
                <li><strong>Forest Fire Model:</strong> Spread simulation</li>
                <li><strong>Vote CA:</strong> Majority rule for smoothing</li>
            </ul>
        </section>

        <section class="info-section">
            <h2>Free Tools & Libraries</h2>
            <ul>
                <li><strong>Golly:</strong> Advanced cellular automata simulator</li>
                <li><strong>HashLife:</strong> Optimized Game of Life algorithm</li>
            </ul>
        </section>

        <section class="info-section">
            <h2>System-Thinking Prompts</h2>
            <ul>
                <li>What happens with extreme densities? 0% or 100%?</li>
                <li>Where do patterns stabilize? Which rules create oscillators?</li>
                <li>How could players exploit deterministic rules? Predict evolution?</li>
                <li>Which parameter dominates? Birth rules or survival rules?</li>
                <li>What's the minimum viable rule set? Simplest interesting pattern?</li>
                <li>How do edge conditions affect patterns? Wrapping vs boundaries?</li>
                <li>Can we guarantee interesting patterns? Or is it trial and error?</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>Developer-Focused</p>
    </footer>

    <script type="module">
        import { DemoFramework } from '../js/framework/DemoFramework.js';
        import { CellularAutomata } from '../js/demos/CellularAutomata.js';

        const framework = new DemoFramework('visualization', {
            width: 800,
            height: 600,
            showStep: true
        });

        const controlsContainer = document.getElementById('controls-container');
        if (framework.controlsPanel) {
            controlsContainer.appendChild(framework.controlsPanel);
        }

        const demo = new CellularAutomata(framework);
    </script>
</body>
</html>
